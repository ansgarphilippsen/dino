#ifndef _POV_MACRO_H
#define _POV_MACRO_H

const char *pov_tri_macro_old="// Triangle Mapping Macro\n//Created by Chris Colefax ccolefax@geocities.com\n#macro get_uvt (P1, P2, P3) #local SX = P2-P1; #local SY = P3-P1; #local SZ = vcross(SX, SY); #declare _UVT = transform {matrix <SX.x, SX.y, SX.z, SY.x, SY.y, SY.z, SZ.x, SZ.y, SZ.z, P1.x, P1.y, P1.z>} #end\n#macro map_cv_texture (P1, C1, P2, C2, P3, C3) texture { #ifdef (triangle_base_texture) triangle_base_texture #end\npigment { #if (C1.red=C2.red & C1.red=C3.red & C1.green=C2.green & C1.green=C3.green & C1.blue=C2.blue & C1.blue=C3.blue & C1.filter=C2.filter & C1.filter=C3.filter & C1.transmit=C2.transmit & C1.transmit=C3.transmit) C1 #else\nget_uvt (P1, P2, P3) average pigment_map {[1 onion pigment_map {[0 C1] [.85 radial pigment_map {[0 C3] [1 C2]} frequency 6]}]  [1 onion pigment_map {[0 C2] [.85 radial pigment_map {[0 C1] [1 C3]} frequency 6]} translate x]  [1 onion pigment_map {[0 C3] [.85 radial pigment_map {[0 C2] [1 C1]} frequency 6]} translate <.5, 0, .8660254>]}\nmatrix <1.01, 0, 0, 0, 0, -1, -.57735, 1.1647, 0, -.005, -.002, 0> transform _UVT #end }} #end\n#macro colored_smooth_triangle (P1, N1, C1, P2, N2, C2, P3, N3, C3) smooth_triangle {P1, N1, P2, N2, P3, N3  map_cv_texture (P1, C1, P2, C2, P3, C3)} #end\n\n";

const char *pov_tri_macro="// Triangle Mapping Macro\n//Modified after macro by Chris Colefax ccolefax@geocities.com\n#macro get_uvt (P1, P2, P3) #local SX = P2-P1; #local SY = P3-P1; #local SZ = vcross(SX, SY); #declare _UVT = transform {matrix <SX.x, SX.y, SX.z, SY.x, SY.y, SY.z, SZ.x, SZ.y, SZ.z, P1.x, P1.y, P1.z>} #end\n#macro map_cv_texture (P1, C1, P2, C2, P3, C3) material { #ifdef (triangle_base_texture) triangle_base_texture #end}\npigment { #if (C1.red=C2.red & C1.red=C3.red & C1.green=C2.green & C1.green=C3.green & C1.blue=C2.blue & C1.blue=C3.blue & C1.filter=C2.filter & C1.filter=C3.filter & C1.transmit=C2.transmit & C1.transmit=C3.transmit) C1 #else\nget_uvt (P1, P2, P3) average pigment_map {[1 onion pigment_map {[0 C1] [.85 radial pigment_map {[0 C3] [1 C2]} frequency 6]}]  [1 onion pigment_map {[0 C2] [.85 radial pigment_map {[0 C1] [1 C3]} frequency 6]} translate x]  [1 onion pigment_map {[0 C3] [.85 radial pigment_map {[0 C2] [1 C1]} frequency 6]} translate <.5, 0, .8660254>]}\nmatrix <1.01, 0, 0, 0, 0, -1, -.57735, 1.1647, 0, -.005, -.002, 0> transform _UVT #end } #end\n#macro colored_smooth_triangle (P1, N1, C1, P2, N2, C2, P3, N3, C3) #if( !(P1.x=P2.x & P1.y=P2.y & P1.z=P2.z) & !(P1.x=P3.x & P1.y=P3.y & P1.z=P3.z) & !(P3.x=P2.x & P3.y=P2.y & P3.z=P2.z)) smooth_triangle {P1, N1, P2, N2, P3, N3 map_cv_texture (P1, C1, P2, C2, P3, C3)} #end #end\n\n";

const char *pov_cyl_macro="// Color Cylinder Macro\n// 1999 Ansgar Philippsen aphilipp@bioz.unibas.ch\n#macro _CC_MakeRotMat(Angle, Axis, Mat) #local _CC_sa=sin(pi*Angle/180.0); #local _CC_ca=cos(pi*Angle/180.0); #local _CC_alen=vlength(Axis); #if(_CC_alen=0.0)	#declare Mat = array[12]{1,0,0,0,1,0,0,0,1,0,0,0} #else	#local _CC_mx=Axis.x/_CC_alen;	#local _CC_my=Axis.y/_CC_alen; #local _CC_mz=Axis.z/_CC_alen; #local _CC_mxx=_CC_mx*_CC_mx; #local _CC_mxy=_CC_mx*_CC_my; #local _CC_mxz=_CC_mx*_CC_mz; #local _CC_myy=_CC_my*_CC_my; #local _CC_myz=_CC_my*_CC_mz; #local _CC_mzz=_CC_mz*_CC_mz;\n#declare Mat = array[12] #declare Mat[0] = _CC_mxx+_CC_ca-_CC_mxx*_CC_ca; #declare Mat[3] = _CC_mxy-_CC_ca*_CC_mxy-_CC_sa*_CC_mz; #declare Mat[6] = _CC_mxz-_CC_ca*_CC_mxz+_CC_sa*_CC_my; #declare Mat[1] = _CC_mxy-_CC_ca*_CC_mxy+_CC_sa*_CC_mz; #declare Mat[4] = _CC_myy+_CC_ca-_CC_ca*_CC_myy; #declare Mat[7] = _CC_myz-_CC_ca*_CC_myz-_CC_sa*_CC_mx; #declare Mat[2] = _CC_mxz-_CC_ca*_CC_mxz-_CC_sa*_CC_my; #declare Mat[5] = _CC_myz-_CC_ca*_CC_myz+_CC_sa*_CC_mx; #declare Mat[8] = _CC_mzz+_CC_ca-_CC_ca*_CC_mzz; #declare Mat[9] = 0.0; #declare Mat[10] = 0.0; #declare Mat[11] = 0.0; #end #end\n#macro color_cylinder (V1,C1,V2,C2,R) #local _CC_mat = array[12]{1,0,0,0,1,0,0,0,1,0,0,0} #local _CC_vcyl = <0.0,0.0,1.0>; #local _CC_vdiff = V2-V1; #local _CC_length = vlength(_CC_vdiff); #local _CC_axis = vcross(_CC_vcyl,_CC_vdiff); #if(_CC_axis.x=0.0 & _CC_axis.y=0.0) #if(_CC_vdiff.z>=0.0) #local _CC_angle=0.0; #else #local _CC_angle=180.0; #end #else #local _CC_dotproduct=vdot(_CC_vcyl,_CC_vdiff); #local _CC_angle=180.0*acos(_CC_dotproduct/_CC_length)/pi; #end _CC_MakeRotMat(_CC_angle,_CC_axis,_CC_mat)	 #local _CC_mat[9]=V1.x; #local _CC_mat[10]=V1.y; #local _CC_mat[11]=V1.z;\ncylinder {<0,0,0>,<0,0,1>,R open pigment { gradient z color_map {[0.0 color C1] [1.0 color C2]}} scale <1,1,_CC_length> matrix <_CC_mat[0],_CC_mat[1],_CC_mat[2],_CC_mat[3],_CC_mat[4],_CC_mat[5],_CC_mat[6],_CC_mat[7],_CC_mat[8],_CC_mat[9],_CC_mat[10],_CC_mat[11]>} #end\n";


#endif

