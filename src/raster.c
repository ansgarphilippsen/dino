#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <math.h>

#include "raster.h"
#include "gfx.h"
#include "scene.h"
#include "dbm.h"
#include "mat.h"
#include "transform.h"

extern struct GFX gfx;
extern struct DBM dbm;

GLdouble raster_mm[16],raster_pm[16];
GLint raster_vp[4];
GLdouble raster_near,raster_far;

int writeRaster(FILE *f)
{
  int i,j;
  struct GFX gsave;
  struct stat st;
  double zoom;
  char message[256];

  raster_near=gfx.transform.slabn;
  raster_far=gfx.transform.slabf;

  glGetDoublev(GL_MODELVIEW_MATRIX,raster_mm);
  glGetDoublev(GL_PROJECTION_MATRIX,raster_pm);
  glGetIntegerv(GL_VIEWPORT,raster_vp);

  if(gfx.mode==GFX_PERSP) {
    memcpy(&gsave,&gfx,sizeof(gsave));
    scenePersp2Ortho();
    zoom=1.0/gfx.scale;
    memcpy(&gfx,&gsave,sizeof(gsave));
  } else {
    zoom=1.0/gfx.scale;
  }


  if(stat("header.r3D",&st)!=0) {

    /* generate Raster3D header */
    
    /* TITLE */
    fprintf(f,"Raster3D (v2.4j or above) output generated by dino\n");
    /* NTX,NTY */
    fprintf(f,"%d %d\n",64,64);
    /* NPX,NPY */
    fprintf(f,"%d %d\n",12,12);
    /* SCHEME */
    fprintf(f,"%d\n",3);
    /* BKGND */
    fprintf(f,"%.2f %.2f %.2f\n",gfx.r,gfx.g,gfx.b);
    /* SHADOW */
    fprintf(f,"%s\n","F");
    /* IPHONG */
    fprintf(f,"%d\n",13);
    /* STRAIT */
    fprintf(f,"%.2f\n",0.25);
    /* AMBIEN */
    fprintf(f,"%.2f\n",0.10);
    /* SPECLR */
    fprintf(f,"%.2f\n",0.30);
    /* EYEPOS */
    fprintf(f,"%.2f\n",0.0);
    /* SOURCE */
    fprintf(f,"%.3f %.3f %.3f\n",
	    gfx.light[0].pos[0],gfx.light[0].pos[1],gfx.light[0].pos[2]);
    /* TMAT */

    fprintf(f,"1 0 0 0\n");
    fprintf(f,"0 1 0 0\n");
    fprintf(f,"0 0 1 0\n");
    fprintf(f,"%f %f %f %f \n",0.0,0.0,0.0,zoom*2.0);

    /* INMODE */
    fprintf(f,"3\n");
    /* INFMTS */
    fprintf(f,"*\n*\n*\n");
  } else {
    sprintf(message,"\nNo header written, suggested zoom: %f",zoom*2.0);
  }


  for(i=0;i<dbm.nodec_max;i++) {
    switch(dbm.node[i].common.type) {
    case DBM_NODE_STRUCT:
      if(dbm.node[i].structNode.xtal!=NULL)
	if(dbm.node[i].structNode.show_cell)
	  writeRasterCell(f,dbm.node[i].structNode.xtal);
      
      for(j=0;j<dbm.node[i].structNode.obj_max;j++)
	if(dbm.node[i].structNode.obj_flag[j]!=0)
	  if(dbm.node[i].structNode.obj[j].render.show)
	    writeRasterStructObj(f,&dbm.node[i].structNode.obj[j]);
      break;
    case DBM_NODE_SCAL:
      if(dbm.node[i].scalNode.xtal!=NULL)
	if(dbm.node[i].scalNode.show_cell)
	  writeRasterCell(f,dbm.node[i].scalNode.xtal);
      for(j=0;j<dbm.node[i].scalNode.obj_max;j++)
	if(dbm.node[i].scalNode.obj[j]!=NULL)
	  if(dbm.node[i].scalNode.obj[j]->render.show)
	    writeRasterScalObj(f,dbm.node[i].scalNode.obj[j]);
      break;
    case DBM_NODE_SURF:
      for(j=0;j<dbm.node[i].surfNode.obj_max;j++)
	if(dbm.node[i].surfNode.obj_flag[j]!=0)
	  if(dbm.node[i].surfNode.obj[j].render.show)
	    writeRasterSurfObj(f,&dbm.node[i].surfNode.obj[j]);
      break;
    case DBM_NODE_GRID:
      for(j=0;j<dbm.node[i].gridNode.obj_max;j++)
	if(dbm.node[i].gridNode.obj_flag[j]!=0)
	  if(dbm.node[i].gridNode.obj[j].render.show)
	    writeRasterGridObj(f,&dbm.node[i].gridNode.obj[j]);
      break;
    case DBM_NODE_GEOM:
      for(j=0;j<dbm.node[i].geomNode.obj_max;j++)
	if(dbm.node[i].geomNode.obj[j]!=NULL)
	  if(dbm.node[i].geomNode.obj[j]->render.show)
	    writeRasterGeomObj(f,dbm.node[i].geomNode.obj[j]);
    }
    
  }
  
  return 0;
}

int writeRasterStructObj(FILE *f,struct STRUCT_OBJ *obj)
{
  int i;
  float p0[3],p1[3],p2[3],p3[3];
  int detail,cf;
  float line_width,bond_width,sphere_radius;
  float col[3];

  detail=obj->render.detail;
  bond_width=obj->render.bond_width;
  sphere_radius=obj->render.sphere_radius;
  line_width=0.05*obj->render.line_width;
  

  if(obj->r==-1.0) {
    cf=1;
  } else {
    cf=0;
    col[0]=obj->r;
    col[1]=obj->g;
    col[2]=obj->b;
  }
  if(obj->render.mode==RENDER_SIMPLE) {
    
    /* thin cylinders */
    for(i=0;i<obj->bond_count;i++) {
      p0[0]=obj->bond[i].atom1->p->x;
      p0[1]=obj->bond[i].atom1->p->y;
      p0[2]=obj->bond[i].atom1->p->z;
      p2[0]=obj->bond[i].atom2->p->x;
      p2[1]=obj->bond[i].atom2->p->y;
      p2[2]=obj->bond[i].atom2->p->z;
      p1[0]=(p2[0]-p0[0])*0.5+p0[0];
      p1[1]=(p2[1]-p0[1])*0.5+p0[1];
      p1[2]=(p2[2]-p0[2])*0.5+p0[2];
      p3[0]=p1[0];
      p3[1]=p1[1];
      p3[2]=p1[2];
      if(cf) {
	col[0]=obj->bond[i].prop1->r;
	col[1]=obj->bond[i].prop1->g;
	col[2]=obj->bond[i].prop1->b;
      }
      writeRasterCylinder(f,&obj->node->transform,3,p0,p1,line_width,col);
      if(cf) {
	col[0]=obj->bond[i].prop2->r;
	col[1]=obj->bond[i].prop2->g;
	col[2]=obj->bond[i].prop2->b;
      }
      p2[0]=obj->bond[i].atom2->p->x;
      p2[1]=obj->bond[i].atom2->p->y;
      p2[2]=obj->bond[i].atom2->p->z;
      writeRasterCylinder(f,&obj->node->transform,3,p3,p2,line_width,col);
    }

    for(i=0;i<obj->s_bond_count;i++) {
      p0[0]=obj->s_bond[i].atom->p->x;
      p0[1]=obj->s_bond[i].atom->p->y;
      p0[2]=obj->s_bond[i].atom->p->z;
      if(cf) {
	col[0]=obj->s_bond[i].prop->r;
	col[1]=obj->s_bond[i].prop->g;
	col[2]=obj->s_bond[i].prop->b;
      }
      /* probably a little sphere will be best */
    }
    
  } else if(obj->render.mode== RENDER_CPK) {
    
    for(i=0;i<obj->atom_count;i++) {
      if(cf) {
	col[0]=obj->atom[i].prop.r;
	col[1]=obj->atom[i].prop.g;
	col[2]=obj->atom[i].prop.b;
      }
      p0[0]=obj->atom[i].ap->p->x;
      p0[1]=obj->atom[i].ap->p->y;
      p0[2]=obj->atom[i].ap->p->z;
      writeRasterSphere(f,&obj->node->transform,2,p0,obj->atom[i].prop.radius,col);
    }
    
  } else if(obj->render.mode== RENDER_CUSTOM) {

    for(i=0;i<obj->bond_count;i++) {

      p0[0]=obj->bond[i].atom1->p->x;
      p0[1]=obj->bond[i].atom1->p->y;
      p0[2]=obj->bond[i].atom1->p->z;
      p2[0]=obj->bond[i].atom2->p->x;
      p2[1]=obj->bond[i].atom2->p->y;
      p2[2]=obj->bond[i].atom2->p->z;
      p1[0]=(p2[0]-p0[0])/2.0+p0[0];
      p1[1]=(p2[1]-p0[1])/2.0+p0[1];
      p1[2]=(p2[2]-p0[2])/2.0+p0[2];
      p3[0]=p1[0];
      p3[1]=p1[1];
      p3[2]=p1[2];
      if(cf) {
	col[0]=obj->bond[i].prop1->r;
	col[1]=obj->bond[i].prop1->g;
	col[2]=obj->bond[i].prop1->b;
      }
      writeRasterCylinder(f,&obj->node->transform,3,p0,p1,bond_width,col);
      if(cf) {
	col[0]=obj->bond[i].prop2->r;
	col[1]=obj->bond[i].prop2->g;
	col[2]=obj->bond[i].prop2->b;
      }
      p2[0]=obj->bond[i].atom2->p->x;
      p2[1]=obj->bond[i].atom2->p->y;
      p2[2]=obj->bond[i].atom2->p->z;
      writeRasterCylinder(f,&obj->node->transform,3,p3,p2,bond_width,col);
      
    }
    
    for(i=0;i<obj->atom_count;i++) {
      if(cf) {
	col[0]=obj->atom[i].prop.r;
	col[1]=obj->atom[i].prop.g;
	col[2]=obj->atom[i].prop.b;
      }
      p0[0]=obj->atom[i].ap->p->x;
      p0[1]=obj->atom[i].ap->p->y;
      p0[2]=obj->atom[i].ap->p->z;
      writeRasterSphere(f,&obj->node->transform,2,p0,sphere_radius,col);
    }
  } else if(obj->render.mode==RENDER_SLINE) {
    for(i=0;i<obj->va.count;i++,i++) {
      writeRasterCylinder(f,&obj->node->transform,3,
			  obj->va.p[i].v,obj->va.p[i+1].v,
			  line_width,obj->va.p[i].c);
    }
  } else if(obj->render.mode==RENDER_TUBE || 
	    obj->render.mode==RENDER_HSC) {
    for(i=0;i<obj->va.count;i++,i++,i++) {
      writeRasterTriangle(f,&obj->node->transform,
			  obj->va.p[i].v,obj->va.p[i+1].v,obj->va.p[i+2].v,
			  obj->va.p[i].n,obj->va.p[i+1].n,obj->va.p[i+2].n,
			  obj->va.p[i].c,obj->va.p[i+1].c,obj->va.p[i+2].c);

    }
  }

  return 0;
}


int writeRasterScalObj(FILE *f,struct SCAL_OBJ *obj)
{
  int i;
  float *v1,*v2,*v3;
  float line_width;
  float point_size;
  float c[3],ct[3];
  
  c[0]=obj->r;
  c[1]=obj->g;
  c[2]=obj->b;

  ct[0]=-1.0;
  ct[1]=-1.0;
  ct[2]=-1.0;

  point_size=0.05*obj->render.point_size;
  line_width=0.05*obj->render.line_width;
  
  switch(obj->type) {
  case SCAL_CONTOUR:
    if(obj->render.mode==RENDER_POINT) {

      /* make little sphere */
      for(i=0;i<obj->point_count;i++) {
	v1=obj->point[i].v;
	writeRasterSphere(f,&obj->node->transform,2,v1,point_size,c);
      }

    } else if(obj->render.mode==RENDER_LINE) {

      /* make thin cylinders */
      if(obj->render.transparency<1.0)
	writeRasterMaterial(f,&obj->node->transform,8,0.0,0.0,ct,(float)obj->render.transparency);

      for(i=0;i<obj->line_count;i++) {
	v1=obj->point[obj->line[i].pi0].v;
	v2=obj->point[obj->line[i].pi1].v;
	writeRasterCylinder(f,&obj->node->transform,3,v1,v2,line_width,c);
      }

      if(obj->render.transparency<1.0)
	writeRasterMaterial(f,&obj->node->transform,9,0.0,0.0,ct,(float)obj->render.transparency);
      
    } else if(obj->render.mode==RENDER_SURFACE) {

      /* make triangles */
      for(i=0;i<obj->face_count;i++) {
	v1=obj->face[i].p0->v;
	v2=obj->face[i].p1->v;
	v3=obj->face[i].p2->v;
      }

    } else {
    }
    break;
  case SCAL_GRID:
    /* make little sphere */
    for(i=0;i<obj->point_count;i++) {
      if(obj->render.mode==RENDER_ON) {
	writeRasterSphere(f,&obj->node->transform,2,
			  obj->point[i].v,
			  obj->point[i].rad,
			  obj->point[i].c);
      } else {
	writeRasterSphere(f,&obj->node->transform,2,
			  obj->point[i].v,
			  point_size,
			  obj->point[i].c);
      }
    }
    break;
  }
  return 0;

}

int writeRasterSurfObj(FILE *f,struct SURF_OBJ *obj)
{
  int i;
  float *v1,*v2,*v3,*n1,*n2,*n3,*c1,*c2,*c3;
  int vi1,vi2,vi3;

  float c[3];

  c[0]=-1.0;
  c[1]=-1.0;
  c[2]=-1.0;
  if(obj->render.transparency<1.0)
    writeRasterMaterial(f,&obj->node->transform,8,0.0,0.0,c,(float)obj->render.transparency);

  for(i=0;i<obj->facec;i++) {
    vi1=obj->face[i*3+0];
    vi2=obj->face[i*3+1];
    vi3=obj->face[i*3+2];

    v1=obj->vert[vi1].p;
    n1=obj->vert[vi1].n;
    c1=obj->vert[vi1].c;
    v2=obj->vert[vi2].p;
    n2=obj->vert[vi2].n;
    c2=obj->vert[vi2].c;
    v3=obj->vert[vi3].p;
    n3=obj->vert[vi3].n;
    c3=obj->vert[vi3].c;

    writeRasterTriangle(f,&obj->node->transform,v1,v2,v3,n1,n2,n3,c1,c2,c3);
  }

  c[0]=-1.0;
  c[1]=-1.0;
  c[2]=-1.0;
  if(obj->render.transparency<1.0)
    writeRasterMaterial(f,&obj->node->transform,9,0.0,0.0,c,(float)obj->render.transparency);
  return 0;

}

int writeRasterGridObj(FILE *f,struct GRID_OBJ *obj)
{
  int i;
  float *v1,*v2,*v3,*n1,*n2,*n3,*c1,*c2,*c3;
  float w1[3],w2[3];
  float line_width;
  int vi1,vi2,vi3;

  float c[3];

  line_width=0.05*obj->render.line_width;

  c[0]=-1.0;
  c[1]=-1.0;
  c[2]=-1.0;
  if(obj->render.transparency<1.0)
    writeRasterMaterial(f,&obj->node->transform,8,0.0,0.0,c,(float)obj->render.transparency);

  if(obj->type==GRID_SURFACE) {
    for(i=0;i<obj->facec;i++) {
      v1=obj->face[i].v1;
      n1=obj->face[i].n1;
      c1=obj->face[i].c1;
      v2=obj->face[i].v2;
      n2=obj->face[i].n2;
      c2=obj->face[i].c2;
      v3=obj->face[i].v3;
      n3=obj->face[i].n3;
      c3=obj->face[i].c3;
      
      writeRasterTriangle(f,&obj->node->transform,v1,v2,v3,n1,n2,n3,c1,c2,c3);
    }
  } else {
    for(i=0;i<obj->vertc;i+=2) {
      w1[0]=obj->vert[i+0].v[0];
      w1[1]=obj->vert[i+0].v[1];
      w1[2]=obj->vert[i+0].v[2];
      w2[0]=obj->vert[i+0].v[0];
      w2[1]=obj->vert[i+0].v[1];
      w2[2]=obj->vert[i+0].v[2];
      c1=obj->vert[i+0].c;
      c2=obj->vert[i+1].c;
      writeRasterCylinder(f,&obj->node->transform,3,v1,v2,line_width,c1);
    }
  }

  c[0]=-1.0;
  c[1]=-1.0;
  c[2]=-1.0;
  if(obj->render.transparency<1.0)
    writeRasterMaterial(f,&obj->node->transform,9,0.0,0.0,c,(float)obj->render.transparency);
  return 0;

}

int writeRasterGeomObj(FILE *f,struct GEOM_OBJ *obj)
{
  int i;
  float *v1,*v2,*v3,*n1,*n2,*n3,*c1,*c2,*c3;

  if(obj->va.p==NULL)
    return -1;

  for(i=0;i<obj->va.count;i+=3) {
    v1=obj->va.p[i+0].v;
    v2=obj->va.p[i+1].v;
    v3=obj->va.p[i+2].v;
    n1=obj->va.p[i+0].n;
    n2=obj->va.p[i+1].n;
    n3=obj->va.p[i+2].n;
    c1=obj->va.p[i+0].c;
    c2=obj->va.p[i+1].c;
    c3=obj->va.p[i+2].c;
    writeRasterTriangle(f,&obj->node->transform,
		      v1,v2,v3,
		      n1,n2,n3,
		      c1,c2,c3);
  }
  return 0;
}

int writeRasterCell(FILE *f,struct XTAL *xtal)
{
  return 0;
}

/*
  subroutines for Raster3D primitives
  the coordinates are normalized AND
  CHECKED against the slab.
*/

int writeRasterTransform(transMat *m, float *v)
{
  double v2[3];

  v2[0]=(double)v[0];
  v2[1]=(double)v[1];
  v2[2]=(double)v[2];
  if(writeRasterTransformd(m,v2)!=1)
    return 0;
  v[0]=(float)v2[0];
  v[1]=(float)v2[1];
  v[2]=(float)v2[2];

  return 1;
}


int writeRasterTransformd(transMat *m, double *v)
{

  GLdouble x,y,z,px,py,pz;
  double tmp[3],in[4],out[4];

  tmp[0]=v[0];
  tmp[1]=v[1];
  tmp[2]=v[2];

  transApply(m,tmp);

  x=tmp[0];
  y=tmp[1];
  z=tmp[2];

  gluProject(x,y,z,raster_mm,raster_pm,raster_vp,&px,&py,&pz);

  if(pz<0.0)
    return 0;
  else if(pz>1.0)
    return 0;
  else if(px<raster_vp[0])
    return 0;
  else if(px>(raster_vp[2]-raster_vp[0]))
    return 0;
  else if(py<raster_vp[1])
    return 0;
  else if(py>(raster_vp[3]-raster_vp[1]))
    return 0;

  in[0]=x;
  in[1]=y;
  in[2]=z;
  in[3]=1.0;

  matMultVM(in,raster_mm,out);

  if(out[3]==0.0)
    return 0;

  v[0]=(out[0]);
  v[1]=(out[1]);
  v[2]=(out[2])-gfx.transform.tra[2];

  return 1;
}


int writeRasterTriangle(FILE *f, transMat *m,
			float *ov1, float *ov2, float *ov3,
			float *on1, float *on2, float *on3, 
			float *oc1, float *oc2, float *oc3)
{
  int i;
  double v[4],r[4];
  double v1[3],v2[3],v3[4],n1[4],n2[4],n3[4];
  double c1[3],c2[3],c3[3];

  for(i=0;i<3;i++) {
    v1[i]=(double)ov1[i];
    v2[i]=(double)ov2[i];
    v3[i]=(double)ov3[i];
    n1[i]=(double)on1[i];
    n2[i]=(double)on2[i];
    n3[i]=(double)on3[i];
  }

  for(i=0;i<3;i++) {
    if(oc1[i]<0.0)
      c1[i]=0.0;
    else
      c1[i]=((double)oc1[i]*oc1[i]);

    if(oc2[i]<0.0)
      c2[i]=0.0;
    else
      c2[i]=((double)oc2[i]*oc2[i]);
    if(oc3[i]<0.0)
      c3[i]=0.0;
    else
      c3[i]=((double)oc3[i]*oc3[i]);
  }

  if(!writeRasterTransformd(m,v1))
    return -1;
  if(!writeRasterTransformd(m,v2))
    return -1;
  if(!writeRasterTransformd(m,v3))
    return -1;

  v[3]=1.0;

  matMultVM(n1,gfx.transform.rot,r);
  matNormalize(r,n1);

  matMultVM(n2,gfx.transform.rot,r);
  matNormalize(r,n2);

  matMultVM(n3,gfx.transform.rot,r);
  matNormalize(r,n3);

  fprintf(f,
	  "1\n%.5f %.5f %.5f  %.5f %.5f %.5f  %.5f %.5f %.5f  %.5f %.5f %.5f\n",
	  v1[0],v1[1],v1[2],
	  v2[0],v2[1],v2[2],
	  v3[0],v3[1],v3[2],
	  c1[0],c1[1],c1[2]);
  
  fprintf(f,
	  "7\n%.5f %.5f %.5f  %.5f %.5f %.5f  %.5f %.5f %.5f\n",
	  n1[0],n1[1],n1[2],
	  n2[0],n2[1],n2[2],
	  n3[0],n3[1],n3[2]);

  fprintf(f,
	  "17\n%.5f %.5f %.5f  %.5f %.5f %.5f  %.5f %.5f %.5f\n",
	  c1[0],c1[1],c1[2],
	  c2[0],c2[1],c2[2],
	  c3[0],c3[1],c3[2]);

  return 0;
}

int writeRasterSphere(FILE *f, transMat *m,int t, float *v1,float r, float *oc)
{
  float c[3];
  if(!writeRasterTransform(m,v1))
    return -1;

  c[0]=oc[0]*oc[0];
  c[1]=oc[1]*oc[1];
  c[2]=oc[2]*oc[2];

  fprintf(f,
	  "%d\n%.3f %.3f %.3f  %.3f  %.3f %.3f %.3f\n",
	  t,
	  v1[0],v1[1],v1[2],r,
	  c[0],c[1],c[2]);
  return 0;
}

int writeRasterCylinder(FILE *f, transMat *m,int t, float *ov1,float *ov2, float r, float *oc)
{
  float c[3];
  float v1[3],v2[3];

  v1[0]=ov1[0]; v1[1]=ov1[1]; v1[2]=ov1[2];
  v2[0]=ov2[0]; v2[1]=ov2[1]; v2[2]=ov2[2];

  if(!writeRasterTransform(m,v1))
    return -1;

  if(!writeRasterTransform(m,v2))
    return -1;

  c[0]=oc[0]*oc[0];
  c[1]=oc[1]*oc[1];
  c[2]=oc[2]*oc[2];

  fprintf(f,
	  "%d\n%.3f %.3f %.3f  %.3f  %.3f %.3f %.3f  1 %.3f %.3f %.3f\n",
	  t,
	  v1[0],v1[1],v1[2],r,
	  v2[0],v2[1],v2[2],
	  c[0],c[1],c[2]);
  return 0;
}

int writeRasterMaterial(FILE *f, transMat *m, int t, float mp, float ms, float *c, float cl)
{
  if(t==9) {
    fprintf(f,"%d\n",t);
  } else {
    fprintf(f,
	    "%d\n%.3f %.3f  %.3f %.3f %.3f  %.3f  0 0 0 0\n",
	    t,
	    mp,ms,c[0],c[1],c[2],1.0-cl);
  }
  return 0;
} 



